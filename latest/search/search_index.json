{
    "docs": [
        {
            "location": "/examples/", 
            "text": "Examples\n\n\n\n\nGraphene Bands\n\n\nusing\n \nHop\n\n\nusing\n \nPyPlot\n\n\n# Lattice vector. Notice that lattice vectors are stored by column.\n\n\nlat\n \n=\n \n[\n1.0\n \n0.5\n \n0.0\n;\n \n0.0\n \n(\n\u221a\n3\n)\n/\n2\n \n0.0\n;\n \n0.0\n \n0.0\n \n1.0\n]\n\n\n# Reduced positions of orbits. Notice that positions are stored by column.\n\n\npositions\n \n=\n \n[\n1\n/\n3\n \n2\n/\n3\n;\n \n1\n/\n3\n \n2\n/\n3\n;\n \n0.0\n \n0.0\n]\n\n\n\ngraphene\n \n=\n \nTightBindingModel\n(\nlat\n,\n \npositions\n)\n\n\n\nsethopping!\n(\ngraphene\n,\n \n1\n,\n \n2\n,\n \n[\n0\n,\n \n0\n,\n \n0\n],\n \n-\n1.0\n)\n \n# \u27e81|H|(0, 0, 0)2\u27e9=-1\n\n\nsethopping!\n(\ngraphene\n,\n \n2\n,\n \n1\n,\n \n[\n1\n,\n \n0\n,\n \n0\n],\n \n-\n1.0\n)\n \n# \u27e82|H|(1, 0, 0)1\u27e9=-1\n\n\nsethopping!\n(\ngraphene\n,\n \n2\n,\n \n1\n,\n \n[\n0\n,\n \n1\n,\n \n0\n],\n \n-\n1.0\n)\n \n# \u27e82|H|(0, 1, 0)1\u27e9=-1\n\n\n\nkdist\n,\n \negvals\n \n=\n \ncalband\n(\ngraphene\n,\n \n[\n1\n \n0\n;\n \n0\n \n1\n;\n \n0\n \n0\n],\n \n100\n)\n\n\n\nplot\n(\nkdist\n,\n \negvals\n[\n1\n,\n \n:\n])\n\n\nplot\n(\nkdist\n,\n \negvals\n[\n2\n,\n \n:\n])\n\n\nsavfig\n(\nbands.png\n)\n\n\n\n\n\n\noutput figure:\n\n\n\n\n\n\nWannier Functions\n\n\nusing\n \nHop\n\n\nlat\n \n=\n \n[\n1.0\n \n0.5\n \n0.0\n;\n \n0.0\n \n(\n\u221a\n3\n)\n/\n2\n \n0.0\n;\n \n0.0\n \n0.0\n \n1.0\n]\n\n\npositions\n \n=\n \n[\n0\n/\n3\n \n1\n/\n3\n;\n \n0\n/\n3\n \n1\n/\n3\n;\n \n0.0\n \n0.0\n]\n\n\n\ngraphene\n \n=\n \nTightBindingModel\n(\nlat\n,\n \npositions\n)\n\n\n\nsethopping!\n(\ngraphene\n,\n \n1\n,\n \n1\n,\n \n[\n0\n,\n \n0\n,\n \n0\n],\n \n-\n1\n)\n\n\nsethopping!\n(\ngraphene\n,\n \n2\n,\n \n2\n,\n \n[\n0\n,\n \n0\n,\n \n0\n],\n \n1\n)\n\n\nsethopping!\n(\ngraphene\n,\n \n1\n,\n \n2\n,\n \n[\n0\n,\n \n0\n,\n \n0\n],\n \n0.1\n)\n\n\nsethopping!\n(\ngraphene\n,\n \n2\n,\n \n1\n,\n \n[\n1\n,\n \n0\n,\n \n0\n],\n \n0.1\n)\n\n\nsethopping!\n(\ngraphene\n,\n \n2\n,\n \n1\n,\n \n[\n0\n,\n \n1\n,\n \n0\n],\n \n0.1\n)\n\n\n\nlfs\n \n=\n \nDict\n{\nVector\n{\nInt64\n},\n \nMatrix\n{\nComplex128\n}}()\n\n\nlfs\n[[\n0\n,\n \n0\n,\n \n0\n]]\n \n=\n \nreshape\n([\n1.0\n;\n \n0.0\n],\n \n(\n2\n,\n \n1\n))\n\n\nwf\n \n=\n \ncalwf\n(\ngraphene\n,\n \nlfs\n,\n \n[\n1\n,],\n \n[\n100\n,\n \n100\n,\n \n1\n],\n \n[\n2\n,\n \n2\n,\n \n0\n]);\n\n\nusing\n \nPyPlot\n\n\npygui\n(\ntrue\n)\n\n\nHop\n.\nPlotting\n.\nplotwf\n(\ngraphene\n,\n \nwf\n,\n \n1\n)\n\n\nshow\n()\n\n\n\n\n\n\noutput figure:\n\n\n\n\n\n\nHofstadter Butterfly\n\n\n\n\nWe are using square lattice to exemplify the Hofstadter Butterfly.\n\n\n\n\nusing\n \nHop\n\n\nusing\n \nPlots\n\n\n\n# Size of the lattice is 15x15\n\n\nsz\n \n=\n \n15\n\n\n# Magnetic flux is varied between 0 flux quantum and 1 flux quantum\n\n\n# by 51 divisions.\n\n\nnmags\n \n=\n \n51\n\n\n# Lattice vector. Notice that lattice vectors are stored by column.\n\n\nlat\n \n=\n \n[\n1.0\n \n0.0\n \n0.0\n;\n \n0.0\n \n1.0\n \n0.0\n;\n \n0.0\n \n0.0\n \n1.0\n]\n\n\n# For a square lattice, there are only one atom in one unit cell.\n\n\npositions\n \n=\n \nArray\n{\nFloat64\n}(\n3\n,\n \n1\n)\n\n\npositions\n[\n:\n,\n \n1\n]\n \n=\n \n[\n0.0\n,\n \n0.0\n,\n \n0.0\n]\n\n\n# Create a tight binding model.\n\n\nt\n \n=\n \nTightBindingModel\n(\nlat\n,\n \npositions\n)\n\n\n# Add hoppings between neighbourhood unit cells\n\n\nsethopping!\n(\nt\n,\n \n1\n,\n \n1\n,\n \n[\n1\n,\n \n0\n,\n \n0\n],\n \n1.0\n)\n \n# \u27e80|H|(1, 0, 0)\u27e9=1\n\n\nsethopping!\n(\nt\n,\n \n1\n,\n \n1\n,\n \n[\n0\n,\n \n1\n,\n \n0\n],\n \n1.0\n)\n \n# \u27e80|H|(0, 1, 0)\u27e9=1\n\n\n# Create a supercell and then create a cluster from the supercell\n\n\nc\n \n=\n \ncutedge\n(\ncutedge\n(\ncutedge\n(\n\n    \nmakesupercell\n(\nt\n,\n \n[\nsz\n \n0\n \n0\n;\n \n0\n \nsz\n \n0\n;\n \n0\n \n0\n \n1\n]),\n \n1\n),\n \n2\n),\n \n3\n)\n\n\n# List of magnetic field.\n\n\nBs\n \n=\n \nlinspace\n(\n0\n,\n \n1\n,\n \nnmags\n)\n\n\n# Eigenvalues.\n\n\negvals\n \n=\n \n[]\n\n\nfor\n \ni\n \nin\n \n1\n:\nnmags\n\n    \n# Add magnetic field. Laudau gauge is used internally.\n\n    \nhofstadter\n \n=\n \naddmagneticfield\n(\nc\n,\n \nBs\n[\ni\n])\n\n    \n# Calculate eigenvalues.\n\n    \npush!\n(\negvals\n,\n \ncaleig\n(\nhofstadter\n,\n \n[\n0.0\n,\n \n0.0\n,\n \n0.0\n]))\n\n\nend\n\n\n# Plot the Butterfly\n\n\ngr\n()\n\n\np\n \n=\n \nplot\n(\nsize\n=\n(\n2000\n,\n2000\n))\n\n\nfor\n \ni\n \nin\n \n1\n:\nnmags\n\n    \nB\n \n=\n \nzeros\n(\nsize\n(\negvals\n[\n1\n]))\n\n    \nfill!\n(\nB\n,\n \nBs\n[\ni\n])\n\n    \nplot!\n(\nB\n,\n \negvals\n[\ni\n],\n \nseriestype\n=:\nscatter\n,\n \nmarkersize\n=\n1\n,\n \nmarkercolor\n=:\nblack\n,\n\n          \nlegend\n=\nfalse\n,\n \nmarkeralpha\n=\n0.05\n,\n \naxis\n=\nnothing\n)\n\n\nend\n\n\nsavefig\n(\nbutterfly.png\n)\n\n\n\n\n\n\noutput figure: (Notice the following butterfly is produced with a 100x100 lattice)", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#graphene-bands", 
            "text": "using   Hop  using   PyPlot  # Lattice vector. Notice that lattice vectors are stored by column.  lat   =   [ 1.0   0.5   0.0 ;   0.0   ( \u221a 3 ) / 2   0.0 ;   0.0   0.0   1.0 ]  # Reduced positions of orbits. Notice that positions are stored by column.  positions   =   [ 1 / 3   2 / 3 ;   1 / 3   2 / 3 ;   0.0   0.0 ]  graphene   =   TightBindingModel ( lat ,   positions )  sethopping! ( graphene ,   1 ,   2 ,   [ 0 ,   0 ,   0 ],   - 1.0 )   # \u27e81|H|(0, 0, 0)2\u27e9=-1  sethopping! ( graphene ,   2 ,   1 ,   [ 1 ,   0 ,   0 ],   - 1.0 )   # \u27e82|H|(1, 0, 0)1\u27e9=-1  sethopping! ( graphene ,   2 ,   1 ,   [ 0 ,   1 ,   0 ],   - 1.0 )   # \u27e82|H|(0, 1, 0)1\u27e9=-1  kdist ,   egvals   =   calband ( graphene ,   [ 1   0 ;   0   1 ;   0   0 ],   100 )  plot ( kdist ,   egvals [ 1 ,   : ])  plot ( kdist ,   egvals [ 2 ,   : ])  savfig ( bands.png )   output figure:", 
            "title": "Graphene Bands"
        }, 
        {
            "location": "/examples/#wannier-functions", 
            "text": "using   Hop  lat   =   [ 1.0   0.5   0.0 ;   0.0   ( \u221a 3 ) / 2   0.0 ;   0.0   0.0   1.0 ]  positions   =   [ 0 / 3   1 / 3 ;   0 / 3   1 / 3 ;   0.0   0.0 ]  graphene   =   TightBindingModel ( lat ,   positions )  sethopping! ( graphene ,   1 ,   1 ,   [ 0 ,   0 ,   0 ],   - 1 )  sethopping! ( graphene ,   2 ,   2 ,   [ 0 ,   0 ,   0 ],   1 )  sethopping! ( graphene ,   1 ,   2 ,   [ 0 ,   0 ,   0 ],   0.1 )  sethopping! ( graphene ,   2 ,   1 ,   [ 1 ,   0 ,   0 ],   0.1 )  sethopping! ( graphene ,   2 ,   1 ,   [ 0 ,   1 ,   0 ],   0.1 )  lfs   =   Dict { Vector { Int64 },   Matrix { Complex128 }}()  lfs [[ 0 ,   0 ,   0 ]]   =   reshape ([ 1.0 ;   0.0 ],   ( 2 ,   1 ))  wf   =   calwf ( graphene ,   lfs ,   [ 1 ,],   [ 100 ,   100 ,   1 ],   [ 2 ,   2 ,   0 ]);  using   PyPlot  pygui ( true )  Hop . Plotting . plotwf ( graphene ,   wf ,   1 )  show ()   output figure:", 
            "title": "Wannier Functions"
        }, 
        {
            "location": "/examples/#hofstadter-butterfly", 
            "text": "We are using square lattice to exemplify the Hofstadter Butterfly.   using   Hop  using   Plots  # Size of the lattice is 15x15  sz   =   15  # Magnetic flux is varied between 0 flux quantum and 1 flux quantum  # by 51 divisions.  nmags   =   51  # Lattice vector. Notice that lattice vectors are stored by column.  lat   =   [ 1.0   0.0   0.0 ;   0.0   1.0   0.0 ;   0.0   0.0   1.0 ]  # For a square lattice, there are only one atom in one unit cell.  positions   =   Array { Float64 }( 3 ,   1 )  positions [ : ,   1 ]   =   [ 0.0 ,   0.0 ,   0.0 ]  # Create a tight binding model.  t   =   TightBindingModel ( lat ,   positions )  # Add hoppings between neighbourhood unit cells  sethopping! ( t ,   1 ,   1 ,   [ 1 ,   0 ,   0 ],   1.0 )   # \u27e80|H|(1, 0, 0)\u27e9=1  sethopping! ( t ,   1 ,   1 ,   [ 0 ,   1 ,   0 ],   1.0 )   # \u27e80|H|(0, 1, 0)\u27e9=1  # Create a supercell and then create a cluster from the supercell  c   =   cutedge ( cutedge ( cutedge ( \n     makesupercell ( t ,   [ sz   0   0 ;   0   sz   0 ;   0   0   1 ]),   1 ),   2 ),   3 )  # List of magnetic field.  Bs   =   linspace ( 0 ,   1 ,   nmags )  # Eigenvalues.  egvals   =   []  for   i   in   1 : nmags \n     # Add magnetic field. Laudau gauge is used internally. \n     hofstadter   =   addmagneticfield ( c ,   Bs [ i ]) \n     # Calculate eigenvalues. \n     push! ( egvals ,   caleig ( hofstadter ,   [ 0.0 ,   0.0 ,   0.0 ]))  end  # Plot the Butterfly  gr ()  p   =   plot ( size = ( 2000 , 2000 ))  for   i   in   1 : nmags \n     B   =   zeros ( size ( egvals [ 1 ])) \n     fill! ( B ,   Bs [ i ]) \n     plot! ( B ,   egvals [ i ],   seriestype =: scatter ,   markersize = 1 ,   markercolor =: black , \n           legend = false ,   markeralpha = 0.05 ,   axis = nothing )  end  savefig ( butterfly.png )   output figure: (Notice the following butterfly is produced with a 100x100 lattice)", 
            "title": "Hofstadter Butterfly"
        }, 
        {
            "location": "/api/", 
            "text": "API reference\n\n\n#\n\n\nHop.TightBindingModel\n \n \nType\n.\n\n\nA tight binding model.\n\n\nGenerally, every tight binding model is three dimensional. Thus every lattice vector should have three components. Lower dimensional models should be simulated by vacuum layer.\n\n\nConstructor Arguments\n\n\n\n\nlat::Matrix{Float64}\n: lattice vector. Lattice vectors should be provided in columns.\n\n\npositions::Matrix{Float64}\n: atom positions in reduced coordinate. Atom positions should be provided in columns.\n\n\nspinful::Bool=false\n: false for spinless systems and true for spinful systems. If \nspinful\n is true, \nnorbits\n will be twice the number of \nsize(positions, 1)\n. Orbits are ordered as (|1\u2191\u27e9, |1\u2193\u27e9, |2\u2191\u27e9, |2\u2193\u27e9, ...).\n\n\n\n\nFields\n\n\n\n\nnorbits::Int\n: number of orbits.\n\n\nlat::Matrix{Float64}\n: lattice vectors stored in columns.\n\n\nrlat::Matrix{Float64}\n: reciprocal lattice vectors stored in columns.\n\n\npositions::Matrix{Float64}\n: position of orbits in reduced coordinate stored in columns.\n\n\nhoppings::Dict{SVector{3,Int64},Matrix{Complex128}}\n: hoppings stored as  R-\n\u27e80n|H|Rm\u27e9.\n\n\n\n\nsource\n\n\n#\n\n\nHop.sethopping!\n \n \nFunction\n.\n\n\nsethopping\n!(\nt\n::\nTightBindingModel\n,\n \nn\n::\nInt64\n,\n \nm\n::\nInt64\n,\n \nR\n::\nVector\n{\nInt64\n}\n,\n \nhopping\n;\n \nmode\n::\nChar\n=\na\n)\n\n\n\n\n\n\nSet \u27e80n|H|Rm\u27e9 to \nhopping\n. \nhopping::Number\n for spinless systems and \nhopping::Matrix{\n:Number}\n for spinful systems. For spinful systems, \nsize(hopping)\n should be (2, 2) and the basis for \nhopping\n is (|\u2191\u27e9, |\u2193\u27e9). \nmode\n has two possible values: 'a' for add mode and 's' for set or reset mode.\n\n\nsource\n\n\n#\n\n\nHop.calhamiltonian\n \n \nFunction\n.\n\n\ncalhamiltonian(t::TightBindingModel, k::Vector{\n:Real}) --\n Matrix{Complex128}\n\n\n\n\n\nCalculate Hamiltonian of a TightBindingModel t for a specific k point. k should be provided in reduced coordinate.\n\n\nsource\n\n\n#\n\n\nHop.caleig\n \n \nFunction\n.\n\n\ncaleig(t::TightBindingModel, k::Vector{\n:Real}, calegvecs::Bool=false)\n\n\n\n\n\nCalculate eigenvalues and eigenvectors of t. k should be provided in reduced coordinate.\n\n\nReturn\n\n\nIf calegvecs is true, \n(egvals::Vector{Float64}, egvecs::Matrix{Complex128})\n, otherwise just \negvals::Vector{Float64}\n. Eigenvectors are stored in columns and eigenvalues are sorted from small to large.\n\n\nsource\n\n\n#\n\n\nHop.calband\n \n \nFunction\n.\n\n\ncalband(t::TightBindingModel, kpath::Matrix{\n:Real}, ndiv::Int64) --\n (Vector{Float64}, Matrix{Float64})\n\n\n\n\n\nCalculate bands. \nkpath\n is a (3, x) size matrix where x is an even number and should be provided in reduced coordinates. This function returns (\nkdist\n, \negvals\n). \nkdist\n is the distance of k points and \negvals\n is the energies of band stored in column at each k.\n\n\nsource\n\n\n#\n\n\nHop.makesupercell\n \n \nFunction\n.\n\n\nmakesupercell(t::TightBindingModel, scrdlat::Matrix{Int64}) --\n TightBindingModel\n\n\n\n\n\nCreate a supercell out of a TightBindingModel t. scrdlat is a 3x3 matrix representing supercell reduced lattice vector in columns.\n\n\nsource\n\n\n#\n\n\nHop.cutedge\n \n \nFunction\n.\n\n\ncutedge\n(\nt\n::\nTightBindingModel\n,\n \ndir\n::\nInt64\n;\n \nglueedges\n::\nBool\n=\nfalse\n)\n\n    \n--\n \nTightBindingModel\n\n\n\n\n\n\nCreate a D-1 dimensional TightBindingModel from a D dimensional one \nt\n. The finite direction is represented by \ndir\n following the convention of 1:x, 2:y, 3:z. If \nglueedges\n is true, the returned TightBindingModel will be made periodic in the \ndir\n direction.\n\n\nsource\n\n\n#\n\n\nHop.addmagneticfield\n \n \nFunction\n.\n\n\naddmagneticfield(t::TightBindingModel, B::Real) --\n TightBindingModel\n\n\n\n\n\nAdd constant magnetic field in z direction for a TightBindingModel.\n\n\nArguments\n\n\n\n\nt::TightBindingModel\n: a TightBindingModel.\n\n\nB::Float64\n: magnetic field in z direction. B is actually Be/h, thus its unit is 1/[length]^2. e here is fundamental charge. Since electron charge is -e, positive B means -z direction for electron system.\n\n\n\n\nsource", 
            "title": "API reference"
        }, 
        {
            "location": "/api/#api-reference", 
            "text": "#  Hop.TightBindingModel     Type .  A tight binding model.  Generally, every tight binding model is three dimensional. Thus every lattice vector should have three components. Lower dimensional models should be simulated by vacuum layer.  Constructor Arguments   lat::Matrix{Float64} : lattice vector. Lattice vectors should be provided in columns.  positions::Matrix{Float64} : atom positions in reduced coordinate. Atom positions should be provided in columns.  spinful::Bool=false : false for spinless systems and true for spinful systems. If  spinful  is true,  norbits  will be twice the number of  size(positions, 1) . Orbits are ordered as (|1\u2191\u27e9, |1\u2193\u27e9, |2\u2191\u27e9, |2\u2193\u27e9, ...).   Fields   norbits::Int : number of orbits.  lat::Matrix{Float64} : lattice vectors stored in columns.  rlat::Matrix{Float64} : reciprocal lattice vectors stored in columns.  positions::Matrix{Float64} : position of orbits in reduced coordinate stored in columns.  hoppings::Dict{SVector{3,Int64},Matrix{Complex128}} : hoppings stored as  R- \u27e80n|H|Rm\u27e9.   source  #  Hop.sethopping!     Function .  sethopping !( t :: TightBindingModel ,   n :: Int64 ,   m :: Int64 ,   R :: Vector { Int64 } ,   hopping ;   mode :: Char = a )   Set \u27e80n|H|Rm\u27e9 to  hopping .  hopping::Number  for spinless systems and  hopping::Matrix{ :Number}  for spinful systems. For spinful systems,  size(hopping)  should be (2, 2) and the basis for  hopping  is (|\u2191\u27e9, |\u2193\u27e9).  mode  has two possible values: 'a' for add mode and 's' for set or reset mode.  source  #  Hop.calhamiltonian     Function .  calhamiltonian(t::TightBindingModel, k::Vector{ :Real}) --  Matrix{Complex128}  Calculate Hamiltonian of a TightBindingModel t for a specific k point. k should be provided in reduced coordinate.  source  #  Hop.caleig     Function .  caleig(t::TightBindingModel, k::Vector{ :Real}, calegvecs::Bool=false)  Calculate eigenvalues and eigenvectors of t. k should be provided in reduced coordinate.  Return  If calegvecs is true,  (egvals::Vector{Float64}, egvecs::Matrix{Complex128}) , otherwise just  egvals::Vector{Float64} . Eigenvectors are stored in columns and eigenvalues are sorted from small to large.  source  #  Hop.calband     Function .  calband(t::TightBindingModel, kpath::Matrix{ :Real}, ndiv::Int64) --  (Vector{Float64}, Matrix{Float64})  Calculate bands.  kpath  is a (3, x) size matrix where x is an even number and should be provided in reduced coordinates. This function returns ( kdist ,  egvals ).  kdist  is the distance of k points and  egvals  is the energies of band stored in column at each k.  source  #  Hop.makesupercell     Function .  makesupercell(t::TightBindingModel, scrdlat::Matrix{Int64}) --  TightBindingModel  Create a supercell out of a TightBindingModel t. scrdlat is a 3x3 matrix representing supercell reduced lattice vector in columns.  source  #  Hop.cutedge     Function .  cutedge ( t :: TightBindingModel ,   dir :: Int64 ;   glueedges :: Bool = false ) \n     --   TightBindingModel   Create a D-1 dimensional TightBindingModel from a D dimensional one  t . The finite direction is represented by  dir  following the convention of 1:x, 2:y, 3:z. If  glueedges  is true, the returned TightBindingModel will be made periodic in the  dir  direction.  source  #  Hop.addmagneticfield     Function .  addmagneticfield(t::TightBindingModel, B::Real) --  TightBindingModel  Add constant magnetic field in z direction for a TightBindingModel.  Arguments   t::TightBindingModel : a TightBindingModel.  B::Float64 : magnetic field in z direction. B is actually Be/h, thus its unit is 1/[length]^2. e here is fundamental charge. Since electron charge is -e, positive B means -z direction for electron system.   source", 
            "title": "API reference"
        }
    ]
}