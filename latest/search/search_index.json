{
    "docs": [
        {
            "location": "/examples/", 
            "text": "Examples\n\n\n\n\nGraphene Bands\n\n\nusing Hop\nusing PyPlot\nrc(\nfont\n, family=\nTimes New Roman\n)\nrc(\nmathtext\n, fontset=\ncm\n)\nrc(\nfont\n, size=10)\n# Lattice vector. Notice that lattice vectors are stored by column.\nlat = [1.0 0.5 0.0; 0.0 (\u221a3)/2 0.0; 0.0 0.0 1.0]\n# Reduced positions of orbits. Notice that positions are stored by column.\npositions = [1/3 2/3; 1/3 2/3; 0.0 0.0]\n\ngraphene = TightBindingModel(lat, positions)\n\nsethopping!(graphene, 1, 2, [0, 0, 0], -1.0) # \u27e81|H|(0, 0, 0)2\u27e9=-1\nsethopping!(graphene, 2, 1, [1, 0, 0], -1.0) # \u27e82|H|(1, 0, 0)1\u27e9=-1\nsethopping!(graphene, 2, 1, [0, 1, 0], -1.0) # \u27e82|H|(0, 1, 0)1\u27e9=-1\n\nkdist, egvals = getband(graphene, [1 0; 0 1; 0 0], 100)\nfigure(figsize=(3, 2.5))\nplot(kdist, egvals[1, :], \nk\n)\nplot(kdist, egvals[2, :], \nk\n)\nxlabel(\n)\nxticks([])\nylabel(\nE(eV)\n)\ntight_layout()\nsavefig(\nband.png\n, dpi=500)\n\n\n\n\noutput figure:", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#graphene-bands", 
            "text": "using Hop\nusing PyPlot\nrc( font , family= Times New Roman )\nrc( mathtext , fontset= cm )\nrc( font , size=10)\n# Lattice vector. Notice that lattice vectors are stored by column.\nlat = [1.0 0.5 0.0; 0.0 (\u221a3)/2 0.0; 0.0 0.0 1.0]\n# Reduced positions of orbits. Notice that positions are stored by column.\npositions = [1/3 2/3; 1/3 2/3; 0.0 0.0]\n\ngraphene = TightBindingModel(lat, positions)\n\nsethopping!(graphene, 1, 2, [0, 0, 0], -1.0) # \u27e81|H|(0, 0, 0)2\u27e9=-1\nsethopping!(graphene, 2, 1, [1, 0, 0], -1.0) # \u27e82|H|(1, 0, 0)1\u27e9=-1\nsethopping!(graphene, 2, 1, [0, 1, 0], -1.0) # \u27e82|H|(0, 1, 0)1\u27e9=-1\n\nkdist, egvals = getband(graphene, [1 0; 0 1; 0 0], 100)\nfigure(figsize=(3, 2.5))\nplot(kdist, egvals[1, :],  k )\nplot(kdist, egvals[2, :],  k )\nxlabel( )\nxticks([])\nylabel( E(eV) )\ntight_layout()\nsavefig( band.png , dpi=500)  output figure:", 
            "title": "Graphene Bands"
        }, 
        {
            "location": "/api/", 
            "text": "API reference\n\n\n\n\nHop\n\n\n#\n\n\nHop.TightBindingModel\n \n \nType\n.\n\n\nTightBindingModel(lat::Matrix{Float64}, positions::Matrix{Float64}; spinful::Bool=false)\n\n\n\n\nA tight binding model.\n\n\nGenerally, every tight binding model is three dimensional. Therefore, every lattice vector should have three components. Lower dimensional models should be simulated by vacuum layer.\n\n\nConstructor Arguments\n\n\n\n\nlat\n: lattice vector. Lattice vectors should be provided in columns.\n\n\npositions\n: atom positions in reduced coordinate. Atom positions should be provided in columns.\n\n\nspinful\n: false for spinless systems and true for spinful systems. If \nspinful\n is true, \nnorbits\n will be twice the number of \nsize(positions, 1)\n. Orbits are ordered as (|1\u2191\u27e9, |1\u2193\u27e9, |2\u2191\u27e9, |2\u2193\u27e9, ...).\n\n\n\n\nFields\n\n\n\n\nnorbits::Int\n: number of orbits.\n\n\nlat::Matrix{Float64}\n: lattice vectors stored in columns.\n\n\nrlat::Matrix{Float64}\n: reciprocal lattice vectors stored in columns.\n\n\npositions::Matrix{Float64}\n: position of orbits in reduced coordinate stored in columns.\n\n\nhoppings::Dict{SVector{3,Int64},Matrix{ComplexF64}}\n: hoppings stored as  R-\n\u27e80m|H|Rn\u27e9.\n\n\n\n\nsource\n\n\n#\n\n\nHop.sethopping!\n \n \nFunction\n.\n\n\nsethopping!(t::TightBindingModel, m::Int64, n::Int64, R, hopping;\n    mode::Symbol=:a)\n\n\n\n\nSet \u27e80m|H|Rn\u27e9 to \nhopping\n. \nhopping::Number\n for spinless models and \nhopping::Matrix{\n:Number}\n for spinful models. For spinful models, \nsize(hopping)\n should be (2, 2) and the basis for \nhopping\n is (|\u2191\u27e9, |\u2193\u27e9). \nmode\n has two possible values: :a for add mode and :s for set or reset mode.\n\n\nsource\n\n\n#\n\n\nHop.gethamiltonian\n \n \nFunction\n.\n\n\ngethamiltonian(t::TightBindingModel, k::Vector{\n:Real}) --\n Matrix{ComplexF64}\n\n\n\n\nCalculate Hamiltonian of a TightBindingModel t for a specific k point. k should be provided in reduced coordinate.\n\n\nsource\n\n\n#\n\n\nHop.geteig\n \n \nFunction\n.\n\n\ngeteig(t::TightBindingModel, k::Vector{\n:Real})\n\n\n\n\nCalculate eigenvalues and eigenvectors of t. k should be provided in reduced coordinate.\n\n\nReturn\n\n\n(egvals::Vector{Float64}, egvecs::Matrix{ComplexF64})\n, Eigenvectors are stored in columns and eigenvalues are sorted from small to large.\n\n\nsource\n\n\n#\n\n\nHop.geteigvals\n \n \nFunction\n.\n\n\ngeteigvals(t::TightBindingModel, k::Vector{\n:Real})\n  --\n Vector{Float64}\n\n\n\n\nCalculate eigenvalues and eigenvectors of t. k should be provided in reduced coordinate.\n\n\nEigenvalues are sorted from small to large.\n\n\nsource\n\n\n#\n\n\nHop.getband\n \n \nFunction\n.\n\n\ngetband(t::TightBindingModel, kpath::Matrix{\n:Real}, ndiv::Int64)\n    --\n (Vector{Float64}, Matrix{Float64})\n\n\n\n\nCalculate bands. \nkpath\n is a (3, x) size matrix where x is an even number and should be provided in reduced coordinates. This function returns (\nkdist\n, \negvals\n). \nkdist\n is the distance of k points and \negvals\n is the energies of band stored in column at each k.\n\n\nsource\n\n\n\n\nHop.Floquet\n\n\n#\n\n\nHop.Floquet.FloquetHamiltonian\n \n \nType\n.\n\n\nFloquetHamiltonian(Hs::Vector{Matrix{T}}, \u03a9::Real, harmonics_cutoff::Integer) where T\n:Number ``` Floquet Hamiltonian.\n\n\nGenerally, Floquet theory deals with time periodic Hamiltonians $H(t+\u03a9)=H(t)$.\n\n\nConstructor Arguments\n\n\n\n\nHs\n is a list of Hamiltonian looking like $[H_0, H_1, H_2, ...]$. $H_n$ is defined as: $H_n=\\frac{1}{T}\\int_0^T e^{in\u03a9t} H(t) dt$.\n\n\n\u03a9\n is the frequency (provided in eV) of the Floquet system.\n\n\nharmonics_cutoff\n determines how many harmonics are used in Floquet Hamiltonian\n\n\n\n\nFields\n\n\n\n\nHs::Vector{Matrix{ComplexF64}}\n, see above explanations.\n\n\nHf::Matrix{ComplexF64}\n is Floquet Hamiltonian. With basis functions defined as $u_n=e^{-in\u03a9t}$, $H^F_{mn}=H_{m-n}-m\u03a9\u03b4_{mn}$. The basis of returned Floquet Hamiltonian is $(e^{iN\u03a9t}, e^{i(N-1)\u03a9t}, ..., e^{-iN\u03a9t})$ where internal states are omitted.\n\n\n\u03a9::Float64\n, see above explanations.\n\n\nnstates::Int64\n is number of internal states.\n\n\nnfstates::Int64\n is number of Floquet states.\n\n\nharmonics_cutoff::Int64\n, see above explanations.\n\n\n\n\nsource\n\n\n#\n\n\nHop.Floquet.get_floquet_occupation\n \n \nFunction\n.\n\n\nget_floquet_occupation(f::FloquetHamiltonian; \u0393::Real=1.0, \u03bc::Real=0.0,\n    atol::Real=1.0e-3) --\n Vector{Float64}\n\n\n\n\nCalculate occupation number of \nf\n assuming coupling to a heat bath with coupling constant \n\u0393\n. Chemical potential of the heat bath is \n\u03bc\n. \natol\n is the integration absolute tolerance.\n\n\nsource\n\n\n#\n\n\nHop.Floquet.get_illuminated_hamiltonian\n \n \nFunction\n.\n\n\nget_illuminated_hamiltonian(t::TightBindingModel, k::Vector{\n:Real};\n    A::Vector{\n:Number}, \u03a9::Real, harmonics_cutoff::Integer=2)\n    --\n FloquetHamiltonian\n\n\n\n\nCalculate Floquet Hamiltonian of \nt\n at \nk\n point under the illumination of light with frequency \u03a9. Peierls substitution is performed to the lowest order. Only electric field is taken into account. The parameter \nA\n looks like $[A_x, A_y, A_z]$ denoting vector potential $A(t)=[A_x, A_y, A_z]e^{-i\u03a9t}+c.c.$. Floquet Hamiltonian is truncated up to \nharmonics_cutoff\n harmonics.\n\n\nsource\n\n\n#\n\n\nHop.Floquet.get_illuminated_band\n \n \nFunction\n.\n\n\nfunction get_illuminated_band(t::TightBindingModel; A::Vector{\n:Number}, \u03a9::Real,\n    kpath::Matrix{\n:Real}, harmonics_cutoff::Integer=2, ndiv::Int64=100)\n    --\n (Vector{Float64}, Matrix{Float64})\n\n\n\n\nCalculate bands of \nt\n under the illumination of light with frequency \u03a9. \nkpath\n is a (3, x) size matrix where x is an even number and should be provided in reduced coordinates. Peierls substitution is performed to the lowest order. Only electric field is taken into account. The parameter \nA\n looks like $[A_x, A_y, A_z]$ denoting vector potential $A(t)=[A_x, A_y, A_z]e^{-i\u03a9t}+c.c.$. Floquet Hamiltonian is truncated up to \nharmonics_cutoff\n harmonics.\n\n\nThis function returns (\nkdist\n, \negvals\n). \nkdist\n is the distance of k points and \negvals\n is the Floquet energies of band stored in column at each k.\n\n\nsource", 
            "title": "API reference"
        }, 
        {
            "location": "/api/#api-reference", 
            "text": "", 
            "title": "API reference"
        }, 
        {
            "location": "/api/#hop", 
            "text": "#  Hop.TightBindingModel     Type .  TightBindingModel(lat::Matrix{Float64}, positions::Matrix{Float64}; spinful::Bool=false)  A tight binding model.  Generally, every tight binding model is three dimensional. Therefore, every lattice vector should have three components. Lower dimensional models should be simulated by vacuum layer.  Constructor Arguments   lat : lattice vector. Lattice vectors should be provided in columns.  positions : atom positions in reduced coordinate. Atom positions should be provided in columns.  spinful : false for spinless systems and true for spinful systems. If  spinful  is true,  norbits  will be twice the number of  size(positions, 1) . Orbits are ordered as (|1\u2191\u27e9, |1\u2193\u27e9, |2\u2191\u27e9, |2\u2193\u27e9, ...).   Fields   norbits::Int : number of orbits.  lat::Matrix{Float64} : lattice vectors stored in columns.  rlat::Matrix{Float64} : reciprocal lattice vectors stored in columns.  positions::Matrix{Float64} : position of orbits in reduced coordinate stored in columns.  hoppings::Dict{SVector{3,Int64},Matrix{ComplexF64}} : hoppings stored as  R- \u27e80m|H|Rn\u27e9.   source  #  Hop.sethopping!     Function .  sethopping!(t::TightBindingModel, m::Int64, n::Int64, R, hopping;\n    mode::Symbol=:a)  Set \u27e80m|H|Rn\u27e9 to  hopping .  hopping::Number  for spinless models and  hopping::Matrix{ :Number}  for spinful models. For spinful models,  size(hopping)  should be (2, 2) and the basis for  hopping  is (|\u2191\u27e9, |\u2193\u27e9).  mode  has two possible values: :a for add mode and :s for set or reset mode.  source  #  Hop.gethamiltonian     Function .  gethamiltonian(t::TightBindingModel, k::Vector{ :Real}) --  Matrix{ComplexF64}  Calculate Hamiltonian of a TightBindingModel t for a specific k point. k should be provided in reduced coordinate.  source  #  Hop.geteig     Function .  geteig(t::TightBindingModel, k::Vector{ :Real})  Calculate eigenvalues and eigenvectors of t. k should be provided in reduced coordinate.  Return  (egvals::Vector{Float64}, egvecs::Matrix{ComplexF64}) , Eigenvectors are stored in columns and eigenvalues are sorted from small to large.  source  #  Hop.geteigvals     Function .  geteigvals(t::TightBindingModel, k::Vector{ :Real})\n  --  Vector{Float64}  Calculate eigenvalues and eigenvectors of t. k should be provided in reduced coordinate.  Eigenvalues are sorted from small to large.  source  #  Hop.getband     Function .  getband(t::TightBindingModel, kpath::Matrix{ :Real}, ndiv::Int64)\n    --  (Vector{Float64}, Matrix{Float64})  Calculate bands.  kpath  is a (3, x) size matrix where x is an even number and should be provided in reduced coordinates. This function returns ( kdist ,  egvals ).  kdist  is the distance of k points and  egvals  is the energies of band stored in column at each k.  source", 
            "title": "Hop"
        }, 
        {
            "location": "/api/#hopfloquet", 
            "text": "#  Hop.Floquet.FloquetHamiltonian     Type .  FloquetHamiltonian(Hs::Vector{Matrix{T}}, \u03a9::Real, harmonics_cutoff::Integer) where T :Number ``` Floquet Hamiltonian.  Generally, Floquet theory deals with time periodic Hamiltonians $H(t+\u03a9)=H(t)$.  Constructor Arguments   Hs  is a list of Hamiltonian looking like $[H_0, H_1, H_2, ...]$. $H_n$ is defined as: $H_n=\\frac{1}{T}\\int_0^T e^{in\u03a9t} H(t) dt$.  \u03a9  is the frequency (provided in eV) of the Floquet system.  harmonics_cutoff  determines how many harmonics are used in Floquet Hamiltonian   Fields   Hs::Vector{Matrix{ComplexF64}} , see above explanations.  Hf::Matrix{ComplexF64}  is Floquet Hamiltonian. With basis functions defined as $u_n=e^{-in\u03a9t}$, $H^F_{mn}=H_{m-n}-m\u03a9\u03b4_{mn}$. The basis of returned Floquet Hamiltonian is $(e^{iN\u03a9t}, e^{i(N-1)\u03a9t}, ..., e^{-iN\u03a9t})$ where internal states are omitted.  \u03a9::Float64 , see above explanations.  nstates::Int64  is number of internal states.  nfstates::Int64  is number of Floquet states.  harmonics_cutoff::Int64 , see above explanations.   source  #  Hop.Floquet.get_floquet_occupation     Function .  get_floquet_occupation(f::FloquetHamiltonian; \u0393::Real=1.0, \u03bc::Real=0.0,\n    atol::Real=1.0e-3) --  Vector{Float64}  Calculate occupation number of  f  assuming coupling to a heat bath with coupling constant  \u0393 . Chemical potential of the heat bath is  \u03bc .  atol  is the integration absolute tolerance.  source  #  Hop.Floquet.get_illuminated_hamiltonian     Function .  get_illuminated_hamiltonian(t::TightBindingModel, k::Vector{ :Real};\n    A::Vector{ :Number}, \u03a9::Real, harmonics_cutoff::Integer=2)\n    --  FloquetHamiltonian  Calculate Floquet Hamiltonian of  t  at  k  point under the illumination of light with frequency \u03a9. Peierls substitution is performed to the lowest order. Only electric field is taken into account. The parameter  A  looks like $[A_x, A_y, A_z]$ denoting vector potential $A(t)=[A_x, A_y, A_z]e^{-i\u03a9t}+c.c.$. Floquet Hamiltonian is truncated up to  harmonics_cutoff  harmonics.  source  #  Hop.Floquet.get_illuminated_band     Function .  function get_illuminated_band(t::TightBindingModel; A::Vector{ :Number}, \u03a9::Real,\n    kpath::Matrix{ :Real}, harmonics_cutoff::Integer=2, ndiv::Int64=100)\n    --  (Vector{Float64}, Matrix{Float64})  Calculate bands of  t  under the illumination of light with frequency \u03a9.  kpath  is a (3, x) size matrix where x is an even number and should be provided in reduced coordinates. Peierls substitution is performed to the lowest order. Only electric field is taken into account. The parameter  A  looks like $[A_x, A_y, A_z]$ denoting vector potential $A(t)=[A_x, A_y, A_z]e^{-i\u03a9t}+c.c.$. Floquet Hamiltonian is truncated up to  harmonics_cutoff  harmonics.  This function returns ( kdist ,  egvals ).  kdist  is the distance of k points and  egvals  is the Floquet energies of band stored in column at each k.  source", 
            "title": "Hop.Floquet"
        }
    ]
}